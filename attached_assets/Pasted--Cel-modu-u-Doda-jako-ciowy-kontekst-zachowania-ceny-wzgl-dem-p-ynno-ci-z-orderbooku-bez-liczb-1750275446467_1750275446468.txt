ğŸ§  Cel moduÅ‚u:
DodaÄ‡ jakoÅ›ciowy kontekst zachowania ceny wzglÄ™dem pÅ‚ynnoÅ›ci z orderbooku â€“ bez liczbowych progÃ³w, tylko detekcje oparte na strukturze i interpretacji.

ğŸ” Wymagane zapytania API (na kaÅ¼dy token):
GET /v5/market/kline â€“ 15M Å›wiece, ostatnie 50

GET /v5/market/kline â€“ 1M Å›wiece, ostatnie 50

GET /v5/market/orderbook?limit=25 â€“ aktualny orderbook (25 bidÃ³w, 25 askÃ³w)

ğŸ§ª ModuÅ‚ heatmap_detectors.py â€“ kod do implementacji
python
Kopiuj
Edytuj
import numpy as np
from utils.bybit_api import get_klines, get_orderbook

def walls_disappear(symbol):
    ob = get_orderbook(symbol)
    bids = [b[1] for b in ob['bids']]
    asks = [a[1] for a in ob['asks']]
    if not bids or not asks:
        return "âŒ"

    bid_median = np.median(bids)
    ask_median = np.median(asks)
    large_bid = any(b > 10 * bid_median for b in bids)
    large_ask = any(a > 10 * ask_median for a in asks)
    return "âœ…" if not (large_bid or large_ask) else "âŒ"

def pinning(symbol):
    klines = get_klines(symbol, interval="1", limit=30)
    ob = get_orderbook(symbol)
    if not klines or not ob:
        return "âŒ"

    prices = [float(c[4]) for c in klines]  # close price
    mid_price = (float(ob['bids'][0][0]) + float(ob['asks'][0][0])) / 2
    pinned = all(abs(p - mid_price) / mid_price < 0.003 for p in prices)  # 0.3% range
    return "âœ…" if pinned else "âŒ"

def void_reaction(symbol):
    klines = get_klines(symbol, interval="1", limit=5)
    if not klines:
        return "âŒ"
    
    closes = [float(k[4]) for k in klines]
    ranges = [abs(float(k[2]) - float(k[3])) for k in klines]
    mean_range = np.mean(ranges)
    recent_range = ranges[-1]

    if recent_range > 1.5 * mean_range:
        return "âœ…"
    return "âŒ"

def cluster_slope(symbol):
    ob = get_orderbook(symbol)
    bids = [(float(p), float(q)) for p, q in ob['bids']]
    asks = [(float(p), float(q)) for p, q in ob['asks']]
    if not bids or not asks:
        return "neutral"

    bid_qs = np.array([q for _, q in bids])
    ask_qs = np.array([q for _, q in asks])
    bid_trend = np.polyfit(range(len(bid_qs)), bid_qs, 1)[0]
    ask_trend = np.polyfit(range(len(ask_qs)), ask_qs, 1)[0]

    if bid_trend > 0 and ask_trend < 0:
        return "bullish"
    elif bid_trend < 0 and ask_trend > 0:
        return "bearish"
    else:
        return "neutral"
ğŸ“¤ Prompt do GPT â€“ przykÅ‚ad integracji z outputem detektorÃ³w
W main_analysis.py dopisz:

python
Kopiuj
Edytuj
from detectors.heatmap_detectors import walls_disappear, pinning, void_reaction, cluster_slope

heatmap_analysis = f"""=== ANALIZA HEATMAPY ORDERBOOKU ===
â€¢ ZnikniÄ™cie Å›cian: {walls_disappear(symbol)}
â€¢ Pinning pÅ‚ynnoÅ›ci: {pinning(symbol)}
â€¢ Reakcja na void: {void_reaction(symbol)}
â€¢ Nachylenie klastrÃ³w: {cluster_slope(symbol)}
"""
I dodaj to do full_prompt:

python
Kopiuj
Edytuj
full_prompt += "\n" + heatmap_analysis
ğŸ“¦ Dodatkowe uwagi:
ProszÄ™ skopiowaÄ‡ brakujÄ…ce funkcje z crypto-scan do utils/, np. get_klines() i get_orderbook(), jeÅ›li nie sÄ… jeszcze obecne.

Nie uÅ¼ywamy zewnÄ™trznego Bookmapa ani pÅ‚atnych API â€“ tylko Bybit.

System dziaÅ‚a z 3 zapytaniami na token.

