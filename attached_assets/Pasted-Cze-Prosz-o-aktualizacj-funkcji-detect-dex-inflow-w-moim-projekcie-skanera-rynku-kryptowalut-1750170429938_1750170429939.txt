CzeÅ›Ä‡,

ProszÄ™ o aktualizacjÄ™ funkcji detect_dex_inflow() w moim projekcie skanera rynku kryptowalut. Nowa wersja powinna:

Dynamicznie wyznaczaÄ‡ prÃ³g inflow jako max(market_cap * 0.0005, 3000 USD)

ZliczaÄ‡ Å‚Ä…cznÄ… wartoÅ›Ä‡ inflow z transakcji do znanych adresÃ³w DEX dla danego chaina (korzystajÄ…c z DEX_ADDRESSES)

FiltrowaÄ‡ mikroskopijne transakcje poniÅ¼ej $50

ZwracaÄ‡ status True i "strong_inflow" jeÅ›li inflow_total â‰¥ threshold

ZwracaÄ‡ "moderate_inflow" jeÅ›li inflow_total â‰¥ 0.5 * threshold i â‰¥ 3 transakcje

W przeciwnym razie zwracaÄ‡ False i "below_threshold"

ObsÅ‚ugiwaÄ‡ bÅ‚Ä™dy i sytuacje wyjÄ…tkowe: brak kontraktu, brak danych, brak transakcji itd.

PoniÅ¼ej peÅ‚na treÅ›Ä‡ funkcji do wklejenia:

python
Kopiuj
Edytuj
import time
from utils.token import get_contract_from_cache
from utils.dex import get_token_transfers
from utils.pricing import get_market_cap, get_price_usd
from data.known_dex_addresses import DEX_ADDRESSES

def detect_dex_inflow(symbol, price_usd):
    try:
        contract_info = get_contract_from_cache(symbol)
        if not contract_info:
            print(f"âš ï¸ Brak kontraktu dla {symbol}")
            return False, "no_contract"

        address = contract_info["address"]
        chain = contract_info["chain"].lower()

        # 1. Pobierz transakcje tokenÃ³w
        txs = get_token_transfers(address, chain)
        if not txs:
            return False, "no_transactions"

        # 2. Ustal prÃ³g inflow dynamicznie
        market_cap = get_market_cap(symbol)
        base_threshold = market_cap * 0.0005  # 0.05% market cap
        min_usd = 3000
        threshold = max(base_threshold, min_usd)

        inflow_total = 0
        inflow_tx_count = 0

        for tx in txs:
            to_addr = tx.get("to", "").lower()
            if to_addr in DEX_ADDRESSES.get(chain, []):
                amount = float(tx["value"]) / (10 ** int(tx.get("decimals", 18)))
                usd_value = amount * price_usd

                if usd_value >= 50:
                    inflow_total += usd_value
                    inflow_tx_count += 1

        # 3. Zdecyduj czy uznaÄ‡ inflow
        if inflow_total >= threshold:
            print(f"âœ… DEX inflow wykryty dla {symbol}: {inflow_total:.2f} USD > prÃ³g {threshold:.2f}")
            return True, "strong_inflow"

        elif inflow_tx_count >= 3 and inflow_total >= threshold * 0.5:
            print(f"ğŸŸ¡ Umiarkowany inflow dla {symbol}: {inflow_total:.2f} USD")
            return True, "moderate_inflow"

        else:
            print(f"âŒ Brak istotnego inflow dla {symbol}")
            return False, "below_threshold"

    except Exception as e:
        print(f"âŒ BÅ‚Ä…d w detect_dex_inflow dla {symbol}: {e}")
        return False, "error"
JeÅ›li bÄ™dzie potrzeba â€” przeÅ›lÄ™ takÅ¼e instrukcje do stealth inflow detection jako kolejny etap.

DziÄ™ki! ğŸš€