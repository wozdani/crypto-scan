 Cel:
ZautomatyzowaÄ‡ dostrajanie wag scoringowych w funkcji simulate_trader_decision_advanced() w zaleÅ¼noÅ›ci od skutecznoÅ›ci wczeÅ›niejszych alertÃ³w (czy byÅ‚y trafne czy nietrafne).

ğŸ” Jak to dziaÅ‚a:
Mamy system scoringowy, ktÃ³ry oblicza finalny score na podstawie rÃ³Å¼nych cech (np. trend_strength, pullback_quality itp.).

KaÅ¼da z tych cech ma swojÄ… wagÄ™.

Ten system generuje alerty.

My zapisujemy te alerty do logÃ³w (logs/advanced_trader_log.txt) wraz z etykietÄ… label: good lub label: bad, ktÃ³ra mÃ³wi czy alert byÅ‚ skuteczny.

Nowy moduÅ‚ feedback_loop_trainer.py analizuje te logi i automatycznie dostraja wagi scoringowe, uczÄ…c siÄ™ ktÃ³re cechy majÄ… wiÄ™ksze znaczenie dla skutecznych alertÃ³w.

âœ… Co naleÅ¼y zrobiÄ‡:
Dodaj plik utils/feedback_loop_trainer.py z poniÅ¼szym kodem (gotowy poniÅ¼ej).

W funkcji simulate_trader_decision_advanced() podmieÅ„ wczytywanie wag na dynamiczne â€“ przez load_weights() z nowego pliku.

Wagi sÄ… trzymane w pliku data/weights/tjde_weights.json.

Trening uruchamiamy poleceniem:

bash
Kopiuj
Edytuj
python3 -m utils.feedback_loop_trainer
ğŸ“ Kod pliku: utils/feedback_loop_trainer.py
python
Kopiuj
Edytuj
import json
from collections import defaultdict
import os

WEIGHTS_FILE = "data/weights/tjde_weights.json"
FEEDBACK_LOG = "logs/advanced_trader_log.txt"

# DomyÅ›lne wagi (jeÅ›li plik nie istnieje)
DEFAULT_WEIGHTS = {
    "trend_strength": 0.25,
    "pullback_quality": 0.2,
    "support_reaction": 0.15,
    "liquidity_pattern_score": 0.1,
    "psych_score": 0.1,
    "htf_supportive_score": 0.1,
    "market_phase_modifier": 0.1
}

def load_weights():
    if os.path.exists(WEIGHTS_FILE):
        with open(WEIGHTS_FILE, "r") as f:
            return json.load(f)
    else:
        return DEFAULT_WEIGHTS.copy()

def save_weights(weights):
    with open(WEIGHTS_FILE, "w") as f:
        json.dump(weights, f, indent=2)

def update_weights_based_on_feedback():
    try:
        with open(FEEDBACK_LOG, "r") as f:
            lines = f.readlines()
    except FileNotFoundError:
        print("âš ï¸ Log file not found.")
        return

    weights = load_weights()
    deltas = defaultdict(float)
    count = 0

    for line in lines:
        if '"final_score"' not in line:
            continue
        try:
            data = json.loads(line)
        except:
            continue

        label = data.get("label", "unknown")  # manual tag: "good" or "bad"
        if label not in ("good", "bad"):
            continue

        multiplier = 1 if label == "good" else -1
        for key, value in data.get("score_breakdown", {}).items():
            deltas[key] += multiplier * value
        count += 1

    if count == 0:
        print("â„¹ï¸ No usable feedback data found.")
        return

    # Adjust weights
    for key in weights:
        adjustment = deltas[key] / count
        weights[key] += adjustment * 0.1  # learning rate

    # Normalize
    total = sum(weights.values())
    for key in weights:
        weights[key] = round(weights[key] / total, 4)

    save_weights(weights)
    print("[TJDE Trainer] Weights updated.")
ğŸ”§ W simulate_trader_decision_advanced():
ZamieÅ„ staÅ‚e wagi na:

python
Kopiuj
Edytuj
from utils.feedback_loop_trainer import load_weights

weights = load_weights()
I uÅ¼ywaj ich przy obliczaniu finalnego score (tak jak dotÄ…d, tylko zamiast hardkodowanych wag).

DziÄ™ki wielkie! Jakby byÅ‚y pytania â€“ mogÄ™ wyjaÅ›niÄ‡ szczegÃ³Å‚y scoringu, struktur danych lub logiki.

Pozdrawiam ğŸš€