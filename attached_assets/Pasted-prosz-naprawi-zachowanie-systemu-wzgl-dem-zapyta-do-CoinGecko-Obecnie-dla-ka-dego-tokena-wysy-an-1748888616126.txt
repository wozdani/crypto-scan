proszÄ™ naprawiÄ‡ zachowanie systemu wzglÄ™dem zapytaÅ„ do CoinGecko. Obecnie dla kaÅ¼dego tokena wysyÅ‚ane jest osobne zapytanie (co prowadzi do bÅ‚Ä™du 429: Too Many Requests). Zamiast tego, system miaÅ‚ wykonywaÄ‡ jedno zapytanie do CoinGecko dla wielu tokenÃ³w naraz (np. /coins/list lub /coins/markets), a nastÄ™pnie dopasowaÄ‡ dane lokalnie.

ProszÄ™ zaimplementowaÄ‡ poniÅ¼szÄ… funkcjÄ™ get_multiple_token_contracts_from_coingecko() oraz zmodyfikowaÄ‡ detect_whale_tx(), tak aby nie byÅ‚o pojedynczych zapytaÅ„ na kaÅ¼dy token:

ğŸ§  Kod do wklejenia w utils/coingecko.py:
python
Kopiuj
Edytuj
import requests
import time

# Cache ID list for performance
COINGECKO_TOKEN_LIST = []

def fetch_coingecko_token_list():
    global COINGECKO_TOKEN_LIST
    if COINGECKO_TOKEN_LIST:
        return COINGECKO_TOKEN_LIST
    try:
        response = requests.get("https://api.coingecko.com/api/v3/coins/list", timeout=10)
        COINGECKO_TOKEN_LIST = response.json()
        return COINGECKO_TOKEN_LIST
    except Exception as e:
        print(f"âŒ BÅ‚Ä…d pobierania listy tokenÃ³w z CoinGecko: {e}")
        return []

def get_multiple_token_contracts_from_coingecko(symbols):
    token_list = fetch_coingecko_token_list()
    result = {}

    for symbol in symbols:
        match = next((t for t in token_list if t["symbol"].lower() == symbol.lower().replace("usdt", "")), None)
        if not match:
            result[symbol] = None
            continue

        try:
            data = requests.get(f"https://api.coingecko.com/api/v3/coins/{match['id']}", timeout=10).json()
            platforms = data.get("platforms", {})
            for chain, address in platforms.items():
                if address:
                    result[symbol] = {
                        "address": address,
                        "chain": chain.lower()
                    }
                    break
            if symbol not in result:
                result[symbol] = None
        except Exception as e:
            print(f"âŒ BÅ‚Ä…d pobierania danych dla {symbol}: {e}")
            result[symbol] = None
            time.sleep(1)  # Optional backoff

    return result
ğŸ” NastÄ™pnie: w detect_stage_minus2_1() lub scan_cycle(), dodaj:
python
Kopiuj
Edytuj
symbols = get_symbols_cached()
coingecko_contracts = get_multiple_token_contracts_from_coingecko(symbols)

for symbol in symbols:
    token_info = token_map.get(symbol)
    if not token_info and symbol in coingecko_contracts:
        token_info = coingecko_contracts[symbol]
ğŸ’¡ DziÄ™ki temu system nie bÄ™dzie spamowaÅ‚ CoinGecko, a zamiast tego zrobi 1 zapytanie do /coins/list, a potem tylko konkretne szczegÃ³Å‚y pobierze dla trafionych symboli.