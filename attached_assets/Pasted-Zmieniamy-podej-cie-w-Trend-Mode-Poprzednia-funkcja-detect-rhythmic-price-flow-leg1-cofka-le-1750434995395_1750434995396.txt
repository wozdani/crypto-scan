Zmieniamy podejÅ›cie w Trend Mode.
Poprzednia funkcja detect_rhythmic_price_flow() (leg1 â†’ cofka â†’ leg2) okazaÅ‚a siÄ™ zbyt sztuczna.
W rzeczywistoÅ›ci rynek porusza siÄ™ z dominujÄ…cym kierunkiem, a nie sztywnÄ… strukturÄ… Å›wiec.

ğŸ§  Cel:
Nowa funkcja wykrywa, czy cena poruszaÅ‚a siÄ™ naturalnie i spÃ³jnie (np. 6x wzrost, 2x cofka, 3x wzrost),
czy chaotycznie i szarpanie (np. up, down, up, down, up...).

âœ… Nowy detektor: detect_directional_flow(prices)
python
Kopiuj
Edytuj
def detect_directional_flow(prices: list[float]) -> bool:
    """
    Wykrywa, czy ruch ceny jest spÃ³jny kierunkowo (niechaotyczny).
    JeÅ›li flow jest chaotyczny â€“ zwraca False.
    """
    if len(prices) < 20:
        return False

    direction_changes = 0
    last_dir = 0

    for i in range(1, len(prices)):
        delta = prices[i] - prices[i-1]
        if delta > 0 and last_dir != 1:
            direction_changes += 1
            last_dir = 1
        elif delta < 0 and last_dir != -1:
            direction_changes += 1
            last_dir = -1

    chaos_ratio = direction_changes / len(prices)

    # jeÅ›li mniej niÅ¼ ~40% zmian kierunku â€“ trend naturalny
    return chaos_ratio < 0.4
âœ… Pobieranie danych (zostaje bez zmian):
python
Kopiuj
Edytuj
def get_price_series_bybit(symbol: str) -> list[float]:
    url = "https://api.bybit.com/v5/market/kline"
    params = {
        "interval": "5",
        "limit": 36,
        "category": "linear",
        "symbol": symbol
    }

    try:
        resp = requests.get(url, params=params, timeout=10)
        data = resp.json()
        if data["retCode"] != 0:
            print(f"âŒ Bybit API error for {symbol}: {data['retMsg']}")
            return []

        return [float(item[4]) for item in data["result"]["list"]]
    except Exception as e:
        print(f"âŒ Exception fetching price series for {symbol}: {e}")
        return []
ğŸ”§ Integracja w trend_mode_pipeline.py:
python
Kopiuj
Edytuj
from detectors.directional_flow_detector import detect_directional_flow, get_price_series_bybit

prices = get_price_series_bybit(symbol)

if prices and detect_directional_flow(prices):
    score += 25
    reasons.append("natural directional price flow detected")
else:
    score -= 10
    reasons.append("chaotic price flow â€“ score penalty")
ğŸ“ˆ Co osiÄ…gamy:
Zero alertÃ³w na szarpanych, memowych tokenach

PeÅ‚na zgodnoÅ›Ä‡ z realnym rytmem rynku

Brak uzaleÅ¼nienia od Å›wiec â€“ tylko zachowanie ceny

Gotowe pod rozbudowÄ™ o AI lub LSTM w przyszÅ‚oÅ›ci

ProszÄ™ o podmianÄ™ poprzedniego detektora na ten nowy (detect_directional_flow)
i integracjÄ™ z pipeline Trend Mode.
Plik moÅ¼na nazwaÄ‡ detectors/directional_flow_detector.py.