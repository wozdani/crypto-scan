CzeÅ›Ä‡,

PotrzebujÄ™ wdroÅ¼enia nowego pipelineâ€™u trend_mode, ktÃ³ry nie korzysta z klasycznej analizy technicznej ani z pre-pumpÃ³w. SkÅ‚ada siÄ™ z dwÃ³ch moduÅ‚Ã³w:

ğŸ§± 1. detect_stage_minus1(data)
Detektor napiÄ™cia rynkowego â€“ dziaÅ‚a na zachowaniu rynku, nie wskaÅºnikach.
Nie uÅ¼ywa scoringu ani twardych warunkÃ³w.

Zachowanie:

Cena nie cofnÄ™Å‚a siÄ™ gÅ‚Ä™boko

Åšwiece sÄ… rytmiczne (ciaÅ‚a podobne)

Brak wickÃ³w paniki

Trend trwa, ale chwilowo pauzuje bez chaosu

âœ… Gdy True, uruchamiamy detekcjÄ™ presji bid/ask.

ğŸ“„ Kod:

python
Kopiuj
Edytuj
def detect_stage_minus1(data):
    if len(data) < 6:
        return False, \"Za maÅ‚o Å›wiec do analizy rytmu\"

    def body(c): return abs(c[4] - c[1])
    def wick_down(c): return c[1] - c[3]
    def total_range(c): return c[2] - c[3]

    last = data[-1]
    three_back = data[-4]

    if last[4] < three_back[4]:
        return False, \"Cena cofnÄ™Å‚a siÄ™ za gÅ‚Ä™boko wzglÄ™dem poprzedniego impulsu\"

    if last[4] < last[1]:
        wick_ratio = wick_down(last) / total_range(last) if total_range(last) else 0
        if wick_ratio < 0.2:
            return False, \"Korekta bez odbicia â€“ moÅ¼liwa panika\"

    body_now = body(last)
    body_prev = body(three_back)
    if body_now == 0 or body_prev == 0:
        return False, \"Brak wyraÅºnych ciaÅ‚ Å›wiec\"

    similarity = min(body_now, body_prev) / max(body_now, body_prev)
    if similarity < 0.6:
        return False, \"Zaburzony rytm ciaÅ‚ Å›wiec â€“ brak harmonii\"

    if last[4] < data[-4][4]:
        return False, \"Trend siÄ™ zaÅ‚amaÅ‚ â€“ kierunek nieutrzymany\"

    return True, \"Ruch wstrzymany, rytm utrzymany, brak paniki â€“ moÅ¼liwe wybicie\"
ğŸ§± 2. detect_orderbook_sentiment(orderbook)
Ocenia nastroje rynkowe przez bid/ask. Nie uÅ¼ywa klasycznych wskaÅºnikÃ³w ani twardych filtrÃ³w.

Zachowanie:

Bidy dominujÄ… wolumenowo

Ask cofajÄ… siÄ™ (spread wÄ…ski)

Te same bidy pojawiajÄ… siÄ™ ponownie (reloading)

ğŸ“„ Kod:

python
Kopiuj
Edytuj
def detect_orderbook_sentiment(orderbook):
    bids = orderbook.get(\"bids\", [])[:10]
    asks = orderbook.get(\"asks\", [])[:10]

    if not bids or not asks:
        return False, \"Brak danych orderbook\"

    total_bid = sum(float(b[1]) for b in bids)
    total_ask = sum(float(a[1]) for a in asks)
    if total_bid < total_ask * 0.8:
        return False, \"Brak przewagi popytu\"

    ask_prices = [float(a[0]) for a in asks]
    bid_prices = [float(b[0]) for b in bids]
    if ask_prices[0] - bid_prices[0] > bid_prices[0] * 0.003:
        return False, \"Spread zbyt szeroki â€“ brak gotowoÅ›ci do transakcji\"

    bid_levels = [round(float(b[0]), 4) for b in bids]
    level_counts = {lvl: bid_levels.count(lvl) for lvl in bid_levels}
    reloaded = any(count > 1 for count in level_counts.values())
    if not reloaded:
        return False, \"Brak sygnaÅ‚Ã³w re-akumulacji na bidach\"

    return True, \"Ask cofajÄ… siÄ™, bidy stabilne, presja popytu aktywna\"
ğŸ” Integracja:
W detect_trend_mode(symbol):

python
Kopiuj
Edytuj
active, reason = detect_stage_minus1(data)
if active:
    orderbook = get_orderbook_from_bybit(symbol)
    sentiment, orderbook_reason = detect_orderbook_sentiment(orderbook)
    if sentiment:
        return True, f\"Trend aktywny + {reason} + {orderbook_reason}\"
DziÄ™ki,
Szefir