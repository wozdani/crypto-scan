Edytuj stage_minus2_1.py i dodaj poni≈ºsze funkcje:
1. üì¶ Na samej g√≥rze:
python
Kopiuj
Edytuj
import json
import os
import requests
2. üì¶ Funkcja get_dex_inflow:
python
Kopiuj
Edytuj
def get_dex_inflow(symbol):
    try:
        with open("token_contract_map.json", "r") as f:
            token_map = json.load(f)

        token_info = token_map.get(symbol)
        if not token_info:
            print(f"‚ö†Ô∏è Brak kontraktu dla {symbol}")
            return 0.0

        address = token_info["address"]
        chain = token_info["chain"]

        # Dob√≥r odpowiedniego API i klucza
        if chain == "ethereum":
            base_url = "https://api.etherscan.io/api"
            api_key = os.getenv("ETHERSCAN_API_KEY")
        elif chain == "bsc":
            base_url = "https://api.bscscan.com/api"
            api_key = os.getenv("BSCSCAN_API_KEY")
        elif chain == "arbitrum":
            base_url = "https://api.arbiscan.io/api"
            api_key = os.getenv("ARBISCAN_API_KEY")
        elif chain == "polygon":
            base_url = "https://api.polygonscan.com/api"
            api_key = os.getenv("POLYGONSCAN_API_KEY")
        elif chain == "optimism":
            base_url = "https://api-optimistic.etherscan.io/api"
            api_key = os.getenv("OPTIMISMSCAN_API_KEY")
        else:
            print(f"‚ö†Ô∏è Chain {chain} nieobs≈Çugiwany jeszcze")
            return 0.0

        params = {
            "module": "account",
            "action": "txlist",
            "address": address,
            "startblock": 0,
            "endblock": 99999999,
            "sort": "desc",
            "apikey": api_key,
        }

        response = requests.get(base_url, params=params, timeout=10)
        data = response.json()
        if data["status"] != "1":
            print(f"‚ö†Ô∏è Brak wynik√≥w inflow dla {symbol}: {data.get('message')}")
            return 0.0

        # Liczymy sumƒô wp≈Çyw√≥w do kontraktu
        inflow_sum = 0.0
        for tx in data["result"][:10]:
            if tx["to"].lower() == address.lower():
                inflow_sum += int(tx["value"]) / (10 ** 18)

        return inflow_sum
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd inflow {symbol}: {e}")
        return 0.0
3. üîÅ W detect_stage_minus2_1() dodaj DEX inflow:
Pod linijkƒÖ:

python
Kopiuj
Edytuj
volume_spike_detected, volume = detect_volume_spike(symbol)
Dodaj:

python
Kopiuj
Edytuj
inflow = get_dex_inflow(symbol)
if inflow > 0.3:  # ‚¨ÖÔ∏è mo≈ºesz ustawiƒá pr√≥g np. 0.3 ETH / BNB / etc.
    signals["dex_inflow"] = True
else:
    inflow = 0.0
Na ko≈Ñcu funkcji zaktualizuj return:

python
Kopiuj
Edytuj
return stage2_pass, signals, inflow