 przechodzimy do implementacji Take Profit Forecast Engine, ktÃ³ry na podstawie sygnaÅ‚Ã³w preâ€‘reaktywnych oszacuje dynamiczne poziomy TP1 / TP2 / TP3 oraz trailing TP.

ðŸŽ¯ Cel moduÅ‚u
ModuÅ‚ prognozuje realistyczny potencjaÅ‚ wzrostu tokena w oparciu o jakoÅ›Ä‡ sygnaÅ‚u â€” pozwala ustawiÄ‡ TP1 / TP2 / TP3 (np. +6%, +15%, +30%) oraz trailing TP dla zarzÄ…dzania pozycjÄ….

ðŸ§  Å¹rÃ³dÅ‚a danych do prognozy
ModuÅ‚ korzysta z:

ppwcs_score â€” ogÃ³lna jakoÅ›Ä‡ sygnaÅ‚u

rsi â€” poziom i zmiana RSI (impuls)

orderbook_imbalance â€” stosunek bid/ask w danym momencie

bookmap_heatmap_score â€” intensywnoÅ›Ä‡ absorpcji lub braku podaÅ¼y

delta_flow_strength â€” intensywnoÅ›Ä‡ napÅ‚ywu kupujÄ…cych (jeÅ›li dostÄ™pna)

type_of_breakout â€” np. squeeze â†’ impulse lub reject â†’ breakout

time_tag â€” pora dnia moÅ¼e wpÅ‚ywaÄ‡ na zasiÄ™g (np. przed/po 15)

âœ… PrzykÅ‚adowa funkcja forecast_take_profit_levels()
python
Kopiuj
Edytuj
def forecast_take_profit_levels(signals: dict) -> dict:
    """
    Szacuje poziomy TP1 / TP2 / TP3 oraz trailing TP (%) na podstawie jakoÅ›ci sygnaÅ‚u.
    """
    base_tp1, base_tp2, base_tp3 = 6, 15, 30  # domyÅ›lne wartoÅ›ci (%)

    ppwcs = signals.get("ppwcs_score", 0)
    rsi = signals.get("rsi", 50)
    delta_flow = signals.get("delta_flow_strength", 0)
    heatmap_score = signals.get("bookmap_heatmap_score", 0)
    orderbook_imbalance = signals.get("orderbook_imbalance", 0)
    breakout_type = signals.get("type_of_breakout", "unknown")
    time_tag = signals.get("time_tag", "other")

    # --- Dynamiczna modyfikacja poziomÃ³w TP ---
    multiplier = 1.0

    if ppwcs > 85:
        multiplier += 0.4
    elif ppwcs > 75:
        multiplier += 0.2
    elif ppwcs < 60:
        multiplier -= 0.2

    if rsi > 68:
        multiplier += 0.15
    elif rsi < 50:
        multiplier -= 0.1

    if delta_flow > 1.5:
        multiplier += 0.1
    if heatmap_score > 1.2:
        multiplier += 0.1
    if orderbook_imbalance > 1.5:
        multiplier += 0.1

    if breakout_type == "squeeze_breakout":
        multiplier += 0.1
    elif breakout_type == "reject_impulse":
        multiplier -= 0.05

    if time_tag in ["before_15", "after_15"]:
        multiplier += 0.05

    # --- Oblicz poziomy TP ---
    tp1 = round(base_tp1 * multiplier, 1)
    tp2 = round(base_tp2 * multiplier, 1)
    tp3 = round(base_tp3 * multiplier, 1)

    # Trailing TP: % aktywowany po TP2
    trailing_tp = round(tp2 * 0.66, 1)

    return {
        "TP1": tp1,
        "TP2": tp2,
        "TP3": tp3,
        "TrailingTP": trailing_tp,
        "multiplier": round(multiplier, 2)
    }
ðŸ”¢ PrzykÅ‚ad wejÅ›cia:
python
Kopiuj
Edytuj
signals = {
    "ppwcs_score": 82,
    "rsi": 71,
    "delta_flow_strength": 1.8,
    "bookmap_heatmap_score": 1.3,
    "orderbook_imbalance": 1.6,
    "type_of_breakout": "squeeze_breakout",
    "time_tag": "after_15"
}
Wynik:

json
Kopiuj
Edytuj
{
  "TP1": 8.6,
  "TP2": 21.5,
  "TP3": 43.0,
  "TrailingTP": 14.2,
  "multiplier": 1.43
}
