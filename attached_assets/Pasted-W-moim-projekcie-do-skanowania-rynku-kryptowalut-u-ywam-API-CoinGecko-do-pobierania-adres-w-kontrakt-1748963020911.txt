W moim projekcie do skanowania rynku kryptowalut uÅ¼ywam API CoinGecko do pobierania adresÃ³w kontraktÃ³w tokenÃ³w (ETH, BSC itd.).
WczeÅ›niej system wykonywaÅ‚ osobne zapytanie dla kaÅ¼dego tokena, co prowadziÅ‚o do bÅ‚Ä™du 429 Too Many Requests.

âœ… Teraz zoptymalizowaÅ‚em ten mechanizm â€” robiÄ™ tylko jedno zapytanie do CoinGecko:

bash
Kopiuj
Edytuj
https://api.coingecko.com/api/v3/coins/list?include_platform=true
Pobieram caÅ‚Ä… listÄ™ tokenÃ³w z ich kontraktami i tworzÄ™ lokalny cache (token_contract_map.json). NastÄ™pnie filtrujÄ™ tylko te symbole, ktÃ³re sÄ… dostÄ™pne na Bybit Perpetual Futures (z API Bybit).

Oto kod uÅ¼ywany do zbudowania cache (plik utils/coingecko.py):

python
Kopiuj
Edytuj
import requests, json, os
from utils.bybit import get_perpetual_symbols

CACHE_FILE = "token_contract_map.json"
COINGECKO_URL = "https://api.coingecko.com/api/v3/coins/list?include_platform=true"

def build_contract_cache():
    print("ğŸ“¥ Pobieram dane z CoinGecko...")
    try:
        response = requests.get(COINGECKO_URL, timeout=15)
        if response.status_code == 200:
            data = response.json()
            bybit_symbols = set(get_perpetual_symbols())
            result = {}

            for item in data:
                symbol = item.get("symbol", "").upper()
                if symbol in bybit_symbols:
                    address = item.get("platforms", {}).get("ethereum")
                    if address:
                        result[symbol] = {"address": address, "chain": "ethereum"}

            with open(CACHE_FILE, "w") as f:
                json.dump(result, f, indent=2)
            print(f"âœ… Zapisano {len(result)} kontraktÃ³w w cache.")
        else:
            print(f"âŒ BÅ‚Ä…d CoinGecko: {response.status_code}")
    except Exception as e:
        print(f"âŒ WyjÄ…tek przy pobieraniu: {e}")

def get_contract(symbol):
    if not os.path.exists(CACHE_FILE):
        build_contract_cache()
    try:
        with open(CACHE_FILE, "r") as f:
            cache = json.load(f)
        return cache.get(symbol.upper(), None)
    except Exception as e:
        print(f"âŒ BÅ‚Ä…d przy odczycie cache: {e}")
        return None
âœ… DziÄ™ki temu aplikacja dziaÅ‚a stabilnie, nie przekracza limitÃ³w API CoinGecko, i analizuje tylko tokeny z futuresÃ³w Bybit.
JeÅ›li sÄ… jakieÅ› zalecenia lub uwagi dot. Replit dotyczÄ…ce cacheâ€™owania plikÃ³w lub ochrony przed timeoutem API, chÄ™tnie je wdroÅ¼Ä™.