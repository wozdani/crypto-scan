W moim projekcie skanujÄ…cym rynek kryptowalut korzystam z API CoinGecko do pobierania kontraktÃ³w tokenÃ³w.
ZbudowaÅ‚em lokalny cache (coingecko_cache.json, ok. 17 000 tokenÃ³w), ale mimo to ciÄ…gle otrzymujÄ™ bÅ‚Ä…d 429 (Too Many Requests).

Wiem, Å¼e przyczynÄ… jest to, Å¼e w niektÃ³rych czÄ™Å›ciach systemu nadal wywoÅ‚ywana jest stara funkcja:

python
Kopiuj
Edytuj
get_contract_from_coingecko(symbol, chain)
ktÃ³ra wykonuje zapytanie do API CoinGecko dla kaÅ¼dego tokena osobno, zamiast korzystaÄ‡ z cache.

âœ… ProszÄ™ o:

UsuniÄ™cie wszÄ™dzie funkcji get_contract_from_coingecko(),

ZamianÄ™ jej na get_contract(symbol) (poniÅ¼ej),

Upewnienie siÄ™, Å¼e Å¼adne inne moduÅ‚y (np. contracts.py, get_token_price_usd, stage_minus2_1.py) nie wykonujÄ… zapytaÅ„ HTTP do CoinGecko,

Upewnienie siÄ™, Å¼e build_coingecko_cache() jest wywoÅ‚ywane tylko jeÅ›li is_cache_valid() zwraca False.

DziÄ™ki temu system bÄ™dzie pobieraÅ‚ dane z CoinGecko tylko raz na 30 minut, a reszta bÄ™dzie dziaÅ‚aÄ‡ w peÅ‚ni z lokalnego cache.

ğŸ“‚ utils/coingecko.py
python
Kopiuj
Edytuj
import requests
import json
import os
from datetime import datetime, timedelta

CACHE_FILE = "coingecko_cache.json"
CACHE_DURATION_MINUTES = 30

def is_cache_valid():
    if not os.path.exists(CACHE_FILE):
        return False
    modified_time = datetime.fromtimestamp(os.path.getmtime(CACHE_FILE))
    return datetime.now() - modified_time < timedelta(minutes=CACHE_DURATION_MINUTES)

def load_cache():
    try:
        with open(CACHE_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception as e:
        print(f"âš ï¸ BÅ‚Ä…d podczas Å‚adowania cache: {e}")
        return {}

def save_cache(data):
    try:
        with open(CACHE_FILE, "w", encoding="utf-8") as f:
            json.dump(data, f)
    except Exception as e:
        print(f"âš ï¸ BÅ‚Ä…d podczas zapisu cache: {e}")

def build_coingecko_cache():
    print("ğŸ“¡ Pobieram listÄ™ tokenÃ³w z CoinGecko (coins/list)...")
    url = "https://api.coingecko.com/api/v3/coins/list?include_platform=true"
    try:
        response = requests.get(url, timeout=15)
        response.raise_for_status()
        coins = response.json()
        id_map = {}
        for coin in coins:
            symbol = coin["symbol"].upper()
            id_map[symbol] = {
                "id": coin["id"],
                "platforms": coin.get("platforms", {})
            }
        save_cache(id_map)
        print(f"âœ… Cache zapisany ({len(id_map)} tokenÃ³w).")
    except requests.exceptions.RequestException as e:
        print(f"âš ï¸ BÅ‚Ä…d pobierania z CoinGecko: {e}")

def get_contract(symbol, chain="ethereum"):
    symbol = symbol.upper()
    chain = chain.lower()

    if not is_cache_valid():
        build_coingecko_cache()

    id_map = load_cache()
    coin = id_map.get(symbol)
    if not coin:
        print(f"âš ï¸ Brak danych dla {symbol}")
        return None

    address = coin["platforms"].get(chain)
    if not address:
        print(f"âš ï¸ Brak kontraktu dla {symbol} na {chain}")
        return None

    return {"address": address, "chain": chain}
ğŸ“‚ utils/contracts.py
python
Kopiuj
Edytuj
from utils.coingecko import get_contract

def get_or_fetch_token_contract(symbol):
    try:
        token_info = get_contract(symbol)
        return token_info
    except Exception as e:
        print(f"âŒ BÅ‚Ä…d pobierania kontraktu dla {symbol}: {e}")
        return None
